"""
PSOâ€‘Guided Construction of Maximumâ€‘Rankâ€‘Distance (MRD) Codes
===========================================================

A minimal research prototype that employs Particle Swarm Optimisation (PSO) to
search for MRD generator matrices in the rankâ€‘metric setting.

Author : BehnamÂ &Â GPTâ€‘4Â coâ€‘pilotÂ ğŸ˜  
Deps   : numpyÂ (â‰¥1.24),Â galoisÂ (â‰¥0.4)

---------------------------------------------------------------------------
â•³ WARNING
This script is intended for "didactic" and "smallâ€‘parameter" experiments only.
The exhaustive enumeration used in "rank_distance()" explodes for large k or qáµ.
---------------------------------------------------------------------------
"""

from itertools import product, combinations
import numpy as np
import galois


# ----------------------------------------------------------------------
#  Helper routines
# ----------------------------------------------------------------------
def generate_nonzero_vectors(field, k):
    """
    All nonâ€‘zero vectors in F^k  (bruteâ€‘force, small k only).

    Parameters
    ----------
    field : galois.GF
        Finite field ğ”½_{q^m}.
    k : int
        Vector length.

    Returns
    -------
    list[np.ndarray]
        List of 1â€‘D field arrays of length k.
    """
    vectors = []
    for tup in product(field.elements, repeat=k):
        if any(el != 0 for el in tup):
            vectors.append(field(tup))
    return vectors


def rank_distance(G):
    """
    Minimum rank distance of the linear code generated by G.

    Parameters
    ----------
    G : field ndarray, shape (k, n)
        Generator matrix over ğ”½_{q^m}.

    Returns
    -------
    int
        d_min(G)  =  min_{u â‰  0}  rank_ğ”½q( Î¦(uG) ).
    """
    field = G.field
    k, n = G.shape
    min_rank = n  # upper bound
    for u in generate_nonzero_vectors(field, k):
        cw = u @ G                                   # lengthâ€‘n vector in ğ”½_{q^m}
        M = np.column_stack([c.vector() for c in cw])  # Î¦(cw) âˆˆ ğ”½_q^{mÃ—n}
        min_rank = min(min_rank, np.linalg.matrix_rank(M))
        if min_rank == 1:
            break
    return min_rank


def generalised_rank_weight(G, r=2):
    """
    Very smallâ€‘scale estimator of the râ€‘th generalised rank weight.

    Parameters
    ----------
    G : field ndarray, shape (k, n)
        Generator matrix.
    r : int
        Subspace dimension.

    Returns
    -------
    int
        d_r(G) = min_{UâŠ‚ğ”½_{q^m}^k, dim(U)=r}  rank_ğ”½q( Î¦(UÂ·G) )
    """
    field = G.field
    weights = []
    for comb in combinations(generate_nonzero_vectors(field, G.shape[0]), r):
        M = np.column_stack([ (u @ G).vector() for u in comb ])  # stack r codewords
        weights.append(np.linalg.matrix_rank(M))
    return min(weights)


# ----------------------------------------------------------------------
#  PSO primitives
# ----------------------------------------------------------------------
def initialise_particles(field, N, k, n):
    """Random fullâ€‘rank initial population."""
    particles = []
    while len(particles) < N:
        G = field.Random((k, n))
        if np.linalg.matrix_rank(G) == k:  # full ğ”½_{q^m}â€‘rank
            particles.append(G)
    return particles


def update_velocity(pos, vel, p_best, g_best, w, c1, c2):
    """
    Booleanâ€‘mask velocity update (heuristic).

    The velocity matrix stores *propensities* in [0,1] that trigger entry
    mutations.  We treat Trueâ†”False differences as Â±1 impulses.
    """
    r1 = np.random.rand(*vel.shape)
    r2 = np.random.rand(*vel.shape)
    mask_p = (p_best != pos).astype(float)
    mask_g = (g_best != pos).astype(float)
    return w * vel + c1 * r1 * mask_p + c2 * r2 * mask_g


def position_update(pos, vel, field, base_mutation=0.30):
    """Apply stochastic mutations to a field matrix according to velocity."""
    new_pos = pos.copy()
    for i in range(pos.shape[0]):
        for j in range(pos.shape[1]):
            if np.random.rand() < base_mutation * abs(vel[i, j]):
                new_pos[i, j] = field.Random()
    return new_pos


# ----------------------------------------------------------------------
#  Main PSO loop
# ----------------------------------------------------------------------
def pso_mrd(
    q=2, m=3, k=2, n=4, d_target=3,
    num_particles=8, max_iter=50,
    use_grw=False
):
    """
    Tiny PSO for proofâ€‘ofâ€‘concept MRD search.

    Returns
    -------
    (G_best, d_best)
        Best generator found and its d_min.
    """
    field = galois.GF(q ** m)

    particles  = initialise_particles(field, num_particles, k, n)
    velocities = [np.zeros((k, n)) for _ in range(num_particles)]
    p_bests     = particles.copy()
    p_best_vals = [rank_distance(G) for G in particles]

    g_best_idx  = int(np.argmax(p_best_vals))
    g_best      = p_bests[g_best_idx].copy()
    g_best_val  = p_best_vals[g_best_idx]

    # Hyperâ€‘parameters
    w, c1, c2 = 0.5, 1.5, 1.5

    for _ in range(max_iter):
        for i in range(num_particles):
            velocities[i] = update_velocity(
                particles[i], velocities[i], p_bests[i], g_best, w, c1, c2
            )
            particles[i] = position_update(particles[i], velocities[i], field)
            score = rank_distance(particles[i])

            if score > p_best_vals[i]:
                p_bests[i], p_best_vals[i] = particles[i].copy(), score
                if score > g_best_val:
                    g_best, g_best_val = particles[i].copy(), score

            if g_best_val >= d_target:
                break
        else:
            continue  # only executed if inner loop did *not* break
        break        # break outer loop if earlyâ€‘stop triggered

    if use_grw:
        print("Generalised rank weight r=2:", generalised_rank_weight(g_best))

    return g_best, g_best_val


# ----------------------------------------------------------------------
#  Quick demo
# ----------------------------------------------------------------------
if __name__ == "__main__":
    print("PSOâ€‘guided search for small MRD codes â€¦")
    best_G, best_d = pso_mrd(
        q=2, m=3, k=2, n=4, d_target=3,
        num_particles=8, max_iter=50,
        use_grw=True
    )
    print("\nBest generator matrix:\n", best_G)
    print("Achieved minimum rank distance:", best_d)


# Similar Expected Result:
# Testing the Implemented PSO-Guided Construction of MRD Codes in Rank Metric
# Generalized Rank Weight (r=2): 0
# Best Generator Matrix:
#  [[0 4 3 3]
#  [5 2 3 5]]
# Minimum Rank Distance: 2
