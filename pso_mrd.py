"""
PSO‑Guided Construction of Maximum‑Rank‑Distance (MRD) Codes
===========================================================

A minimal research prototype that employs Particle Swarm Optimisation (PSO) to
search for MRD generator matrices in the rank‑metric setting.

Author : Behnam Dehghani  
Deps   : numpy (≥1.24), galois (≥0.4)

---------------------------------------------------------------------------
╳ WARNING
This script is intended for "didactic" and "small‑parameter" experiments only.
The exhaustive enumeration used in "rank_distance()" explodes for large k or qᵐ.
---------------------------------------------------------------------------
"""

from itertools import product, combinations
import numpy as np
import galois


# ----------------------------------------------------------------------
#  Helper routines
# ----------------------------------------------------------------------
def _get_field(arr):
    """
    Return the galois.GF field object associated with `arr`
    in a way that works for both old and new galois versions.
    """
    # ≥ v0.4  →  ndarray.field
    if hasattr(arr, "field"):
        return arr.field
    # ≤ v0.3  →  ndarray.GF
    if hasattr(arr, "GF"):
        return arr.GF
    # Fallback (slow): derive from the element’s class
    return type(arr[0, 0])


def generate_nonzero_vectors(field, k):
    """
    All non‑zero vectors in F^k  (brute‑force, small k only).

    Parameters
    ----------
    field : galois.GF
        Finite field 𝔽_{q^m}.
    k : int
        Vector length.

    Returns
    -------
    list[np.ndarray]
        List of 1‑D field arrays of length k.
    """
    vectors = []
    for tup in product(field.elements, repeat=k):
        if any(el != 0 for el in tup):
            vectors.append(field(tup))
    return vectors


def rank_distance(G):
    """
    Minimum rank distance of the linear code generated by G.

    Parameters
    ----------
    G : field ndarray, shape (k, n)
        Generator matrix over 𝔽_{q^m}.

    Returns
    -------
    int
        d_min(G)  =  min_{u ≠ 0}  rank_𝔽q( Φ(uG) ).
    """
    field = _get_field(G)
    k, n = G.shape
    min_rank = n  # upper bound
    for u in generate_nonzero_vectors(field, k):
        cw = u @ G                                   # length‑n vector in 𝔽_{q^m}
        M = np.column_stack([c.vector() for c in cw])  # Φ(cw) ∈ 𝔽_q^{m×n}
        min_rank = min(min_rank, np.linalg.matrix_rank(M))
        if min_rank == 1:
            break
    return min_rank


def generalised_rank_weight(G, r=2):
    """
    Very small‑scale estimator of the r‑th generalised rank weight.

    Parameters
    ----------
    G : field ndarray, shape (k, n)
        Generator matrix.
    r : int
        Subspace dimension.

    Returns
    -------
    int
        d_r(G) = min_{U⊂𝔽_{q^m}^k, dim(U)=r}  rank_𝔽q( Φ(U·G) )
    """
    field = _get_field(G)
    weights = []
    for comb in combinations(generate_nonzero_vectors(field, G.shape[0]), r):
        M = np.column_stack([ (u @ G).vector() for u in comb ])  # stack r codewords
        weights.append(np.linalg.matrix_rank(M))
    return min(weights)


# ----------------------------------------------------------------------
#  PSO primitives
# ----------------------------------------------------------------------
def initialise_particles(field, N, k, n):
    """Random full‑rank initial population."""
    particles = []
    while len(particles) < N:
        G = field.Random((k, n))
        if np.linalg.matrix_rank(G) == k:  # full 𝔽_{q^m}‑rank
            particles.append(G)
    return particles


def update_velocity(pos, vel, p_best, g_best, w, c1, c2):
    """
    Boolean‑mask velocity update (heuristic).

    The velocity matrix stores *propensities* in [0,1] that trigger entry
    mutations.  We treat True↔False differences as ±1 impulses.
    """
    r1 = np.random.rand(*vel.shape)
    r2 = np.random.rand(*vel.shape)
    mask_p = (p_best != pos).astype(float)
    mask_g = (g_best != pos).astype(float)
    return w * vel + c1 * r1 * mask_p + c2 * r2 * mask_g


def position_update(pos, vel, field, base_mutation=0.30):
    """Apply stochastic mutations to a field matrix according to velocity."""
    new_pos = pos.copy()
    for i in range(pos.shape[0]):
        for j in range(pos.shape[1]):
            if np.random.rand() < base_mutation * abs(vel[i, j]):
                new_pos[i, j] = field.Random()
    return new_pos


# ----------------------------------------------------------------------
#  Main PSO loop
# ----------------------------------------------------------------------
def pso_mrd(
    q=2, m=3, k=2, n=4, d_target=3,
    num_particles=8, max_iter=50,
    use_grw=False
):
    """
    Tiny PSO for proof‑of‑concept MRD search.

    Returns
    -------
    (G_best, d_best)
        Best generator found and its d_min.

    Similar expected results
    -------
    PSO‑guided search for small MRD codes …
    Generalised rank weight r=2: 2
    
    Best generator matrix:
     [[4 3 3 2]
     [0 5 6 1]]
    Achieved minimum rank distance: 2
    """
    field = galois.GF(q ** m)

    particles  = initialise_particles(field, num_particles, k, n)
    velocities = [np.zeros((k, n)) for _ in range(num_particles)]
    p_bests     = particles.copy()
    p_best_vals = [rank_distance(G) for G in particles]

    g_best_idx  = int(np.argmax(p_best_vals))
    g_best      = p_bests[g_best_idx].copy()
    g_best_val  = p_best_vals[g_best_idx]

    # Hyper‑parameters
    w, c1, c2 = 0.5, 1.5, 1.5

    for _ in range(max_iter):
        for i in range(num_particles):
            velocities[i] = update_velocity(
                particles[i], velocities[i], p_bests[i], g_best, w, c1, c2
            )
            particles[i] = position_update(particles[i], velocities[i], field)
            score = rank_distance(particles[i])

            if score > p_best_vals[i]:
                p_bests[i], p_best_vals[i] = particles[i].copy(), score
                if score > g_best_val:
                    g_best, g_best_val = particles[i].copy(), score

            if g_best_val >= d_target:
                break
        else:
            continue  # only executed if inner loop did *not* break
        break        # break outer loop if early‑stop triggered

    if use_grw:
        print("Generalised rank weight r=2:", generalised_rank_weight(g_best))

    return g_best, g_best_val


# ----------------------------------------------------------------------
#  Quick demo
# ----------------------------------------------------------------------
if __name__ == "__main__":
    print("PSO‑guided search for small MRD codes …")
    best_G, best_d = pso_mrd(
        q=2, m=3, k=2, n=4, d_target=3,
        num_particles=8, max_iter=50,
        use_grw=True
    )
    print("\nBest generator matrix:\n", best_G)
    print("Achieved minimum rank distance:", best_d)
